### mixer

1. 现实世界中的股票市场是一个动态集合。
设 $U_t$ 为在交易日 $t$ 上市交易的所有股票集合。显然，$U_{t} \neq U_{t+1}$。
每天都有IPO上市，也有股票退市。
2. 临时停牌或延迟开盘（如10:30开盘）
A股票9:30开始交易产生数据,B股票10:30开始交易产生数据

---

**Indicator Mixing**（指标混合）：
作用于特征维度 $F$。它假设每个时间步的特征向量是完整的。如果存在NaN（空值），梯度传播将中断。
**Time Mixing**（时间混合）：
作用于时间维度 $T$。它依赖于严格的时间因果律。确保 $t$ 时刻只能看到 $t$ 及之前的信息。
**Stock Mixing**（股票混合）：
作用于截面维度 $N$。旨在捕捉“市场对个股”和“个股对市场”的影响 。
要求同一时刻 $t$，张量切片 $\mathcal{X}_{:, t, :}$ 必须包含所有股票在同一物理时刻的状态。如果因为退市或停牌导致数据缺失，不仅该股票的信息丢失，更重要的是，“市场整体”的表征（Market Representation）会被扭曲。

因此，数据预处理不仅仅是清洗，而是在构建一个高维的、稀疏的、动态的时空张量。

其输入被定义为 $\mathcal{X} \in \mathbb{R}^{N \times T \times F}$ 。
$N$: 股票数量。
$T$: 回看窗口长度（Lookback Window）。
$F$: 特征数量。

我们需要定义一个“全集宇宙”（Union Universe），即训练期间出现过的所有股票的并集：$$\mathcal{U}_{total} = \bigcup_{t=T_{start}}^{T_{end}} U_t$$令 $N = |\mathcal{U}_{total}|$。对于任意一天 $t$，如果不属于 $U_t$ 的股票（即当日未上市或已退市），其在张量中的位置必须被保留，但通过某种方式标记为“无效”。

不仅需要输入张量 $\mathcal{X}$，还需要一个同维度的二值掩码张量 $\mathcal{M} \in \{0, 1\}^{N \times T}$。对于股票 $i$ 在时间 $t$：$$m_{i,t} = \begin{cases} 
1 & \text{if stock } i \text{ is active and trading at time } t \\
0 & \text{otherwise (delisted, halted, or pre-IPO)}
\end{cases}$$
假设预测值为 $\hat{y}$，真实值为 $y$，损失函数 $\mathcal{L}$ 通常定义为：$$\mathcal{L} = \frac{\sum_{i=1}^{N} \sum_{t=1}^{T'} m_{i,t} \cdot \text{MSE}(\hat{y}_{i,t}, y_{i,t})}{\sum_{i=1}^{N} \sum_{t=1}^{T'} m_{i,t}}$$
如果不使用掩码，而是简单地将退市股票的数据填充为0，模型会试图预测“0收益率”。这会导致模型倾向于输出保守的预测（接近0），因为在大部分时间步中（退市后），收益率确实是0, 这被称为“零值陷阱”。

---

我是一名博士生，我想学习一下[股票量化的数据处理]，特别是[https://github.com/SJTU-DMTai/StockMixer]这篇论文。

以老师教导学生的风格教授我，循序渐进，言简意赅。  
1. 逐步引导，推导核心概念。[数据处理]
2. 深入讲解关键细节或进阶内容，保持清晰。[非常重要--深入讲解]  
3. 最后提供相关代码，并简要解释代码逻辑。  
确保每步逻辑连贯，语言亲切，像老师一样耐心引导。

我现在每一只股票数据样例ohlcv:
```
    datetime   open   high    low  close  volume   
0  2025-01-02 09:31:00  30.36  30.47  30.13  30.15   674.0 
1  2025-01-02 09:32:00  30.14  30.14  30.01  30.03   491.0 
...
38638  2025-08-29 14:59:00  40.50  40.50  40.50  40.50     0.0   
38639  2025-08-29 15:00:00  40.50  40.50  40.50  40.50   887.0 
```
假设我最开始研究的大盘3000只股票,在某一天有一些股票退市了,我这种怎么解决呢？
或者说某股票只有从10:30才开盘,这种数据怎么解决呢?

帮我写一下数据处理的代码

---

```
quantitative_log/
└── data
    └── 2012
        ├── SH.600000.csv
        ├── SH.600001.csv
        ├── SH.600002.csv
        └── SH.600003.csv
    └── 2013
        ├── SH.600001.csv
        ├── SH.600002.csv
        ├── SH.600003.csv
        └── SH.600004.csv
```